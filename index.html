// 1. LIMPEZA DE CACHE QUANDO A PARTIDA ACABAR

// Fun√ß√£o melhorada para limpar o cache do jogador
function clearPlayerCache() {
  console.log("Limpando cache do jogador...");
  localStorage.removeItem("opoderdedo_gameId");
  localStorage.removeItem("opoderdedo_playerKey");
  localStorage.removeItem("opoderdedo_playerName");
  localStorage.removeItem("opoderdedo_playerPhoto");
  
  // Tamb√©m limpar quaisquer outras vari√°veis de estado
  gameCode = null;
  myPlayerKey = null;
  playerPhoto = null;
  
  console.log("Cache do jogador limpo com sucesso");
}

// Chamada da fun√ß√£o em todos os pontos necess√°rios
// Em endGameHost()
function endGameHost() {
  if (confirm("Tem certeza que deseja encerrar a partida?")) {
    db.ref(`games/${gameCode}`).update({status: 'finished'})
      .then(() => {
        // Limpar cache do organizador tamb√©m
        clearPlayerCache();
        alert("Partida encerrada com sucesso!");
        setTimeout(() => location.reload(), 1000);
      })
      .catch(error => alert("Erro ao encerrar partida: " + error.message));
  }
}

// Em updatePlayerView() - quando status √© 'finished'
// Trecho que j√° existe, mas garantir que tem a chamada para clearPlayerCache()
if(gameData.status === 'finished'){
  alert("Esta partida foi encerrada!");
  clearPlayerCache();
  setTimeout(() => location.reload(), 1000); // Recarrega ap√≥s o alerta
}


// 2. OP√á√ÉO DE PUXAR NOVO BARALHO

// Fun√ß√£o para gerar um novo baralho
function createNewDeck() {
  btnNewDeck.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Gerando...';
  btnNewDeck.disabled = true;
  
  const newDeck = generateDeck();
  
  db.ref(`games/${gameCode}/deck`).set(newDeck)
    .then(() => {
      addLog("üé¥ Novo baralho gerado pelo organizador!");
      btnNewDeck.innerHTML = '<i class="fas fa-sync-alt"></i> Novo Baralho';
      btnNewDeck.disabled = false;
    })
    .catch(error => {
      alert("Erro ao gerar novo baralho: " + error.message);
      btnNewDeck.innerHTML = '<i class="fas fa-sync-alt"></i> Novo Baralho';
      btnNewDeck.disabled = false;
    });
}

// Adicionando o bot√£o na interface do organizador (em renderHostGame)
// Mostrar bot√£o de novo baralho quando estiver vazio
if (!data.deck || data.deck.length === 0) {
  btnNewDeck.style.display = 'inline-block';
} else {
  btnNewDeck.style.display = 'none';
}

// Definir o evento do bot√£o
btnNewDeck.onclick = createNewDeck;


// 3. OP√á√ïES DE USO DO PODER DO DEDO E CORINGA

// Fun√ß√£o para o organizador usar o coringa de um jogador
function useJokerAsHost(playerIndex) {
  const allKeys = Object.keys(gameData.players || {});
  const playerKey = allKeys[playerIndex];
  
  if (!playerKey) return;
  
  db.ref(`games/${gameCode}/players/${playerKey}`).once('value', snap => {
    const p = snap.val();
    if (!p || p.jokers <= 0) return;
    
    db.ref(`games/${gameCode}/players/${playerKey}/jokers`).set(p.jokers - 1);
    addLog(`üÉè ${p.name} usou 1 Coringa (acionado pelo organizador)`);
  });
}

// Fun√ß√£o para o organizador ativar o poder do dedo de um jogador
function activateFingerAsHost(playerIndex) {
  const allKeys = Object.keys(gameData.players || {});
  const playerKey = allKeys[playerIndex];
  
  if (!playerKey) return;
  
  db.ref(`games/${gameCode}/players/${playerKey}`).once('value', snap => {
    const p = snap.val();
    if (!p || !p.hasFingerPower) return;
    
    const name = p.name || 'Jogador';
    
    // Primeiro remove o poder do dedo do jogador
    db.ref(`games/${gameCode}/players/${playerKey}/hasFingerPower`).set(false);
    
    // Ent√£o ativa o poder do dedo global
    db.ref(`games/${gameCode}/fingerPower`).set({
      active: true, 
      owner: playerKey,
      queue: [{playerKey: playerKey, name}],
      startTime: Date.now() // Adicionar timestamp para controle
    });
    
    addLog(`üëÜ ${name} ativou o Poder do Dedo! (acionado pelo organizador)`);
  });
}

// No renderHostGame, adicionar bot√µes para cada jogador:
hostPlayersStatus.innerHTML = players.map((p, i) => {
  const isCurrent = (i === data.currentPlayerIndex);
  let avatarContent = p.name.charAt(0).toUpperCase();
  
  // Usar foto se dispon√≠vel (manter essa funcionalidade)
  let avatarHtml = '';
  if (p.photo) {
    avatarHtml = `<img src="${p.photo}" alt="${p.name}" />`;
  } else {
    avatarHtml = avatarContent;
  }
  
  let html = `<div class="player-item ${isCurrent ? 'current' : ''} ${p.hasFingerPower ? 'finger-power' : ''}">
    <div class="player-avatar" ${p.hasFingerPower ? 'style="background: var(--warning); color: var(--dark);"' : ''}>
      ${avatarHtml}
    </div>
    <div class="player-name">${p.name}</div>
    <div class="player-badges">`;
  
  if (isCurrent) {
    html += `<span class="badge badge-turn"><i class="fas fa-play"></i> Vez</span>`;
  }
  
  if (p.jokers && p.jokers > 0) {
    html += `<span class="badge badge-joker"><i class="fas fa-magic"></i> ${p.jokers}</span>`;
  }
  
  if (p.hasFingerPower) {
    html += `<span class="badge" style="background-color: var(--warning); color: var(--dark);"><i class="fas fa-hand-point-up"></i> Poder do Dedo</span>`;
  }
  
  html += `</div>`;
  
  // Adicionar bot√µes de a√ß√£o para o organizador
  html += `<div class="player-actions">`;
  
  if (p.jokers && p.jokers > 0) {
    html += `<button class="btn-sm btn-info use-joker-host" data-player="${i}">
      <i class="fas fa-magic"></i> Usar Coringa
    </button>`;
  }
  
  if (p.hasFingerPower) {
    html += `<button class="btn-sm btn-warning activate-finger-host" data-player="${i}">
      <i class="fas fa-hand-point-up"></i> Ativar Poder
    </button>`;
  }
  
  html += `</div></div>`;
  return html;
}).join('');

// Adicionar eventos para os bot√µes
document.querySelectorAll('.use-joker-host').forEach(btn => {
  btn.addEventListener('click', function() {
    const playerIndex = this.getAttribute('data-player');
    useJokerAsHost(playerIndex);
  });
});

document.querySelectorAll('.activate-finger-host').forEach(btn => {
  btn.addEventListener('click', function() {
    const playerIndex = this.getAttribute('data-player');
    activateFingerAsHost(playerIndex);
  });
});


// 4. MEC√ÇNICA DO PODER DO DEDO (√öLTIMO A CLICAR BEBE)

// Melhoria na fun√ß√£o finalizeFingerPower para garantir que o √∫ltimo a clicar bebe
function finalizeFingerPower() {
  db.ref(`games/${gameCode}/fingerPower`).once('value', snap => {
    const fp = snap.val();
    if(!fp || !fp.queue || fp.queue.length === 0) return;
    
    // O √∫ltimo jogador a clicar (ou que n√£o clicou) deve beber
    // Primeiro, precisamos de uma lista de todos os jogadores
    db.ref(`games/${gameCode}/players`).once('value', playersSnap => {
      const players = playersSnap.val() || {};
      const allPlayerKeys = Object.keys(players);
      
      // Lista de jogadores que clicaram
      const clickedPlayerKeys = fp.queue.map(item => item.playerKey);
      
      // Encontrar jogadores que n√£o clicaram
      const nonClickedPlayerKeys = allPlayerKeys.filter(key => !clickedPlayerKeys.includes(key));
      
      if (nonClickedPlayerKeys.length > 0) {
        // Se algu√©m n√£o clicou, o √∫ltimo a n√£o clicar bebe
        const lastNonClickedKey = nonClickedPlayerKeys[nonClickedPlayerKeys.length - 1];
        const lastNonClickedName = players[lastNonClickedKey]?.name || 'Jogador';
        
        addLog(`‚è∞ ${lastNonClickedName} n√£o clicou no Poder do Dedo e deve beber!`);
        db.ref(`games/${gameCode}/players/${lastNonClickedKey}/needsToDrink`).set(Date.now());
      } else {
        // Se todos clicaram, o √∫ltimo a clicar bebe
        const lastClickedItem = fp.queue[fp.queue.length - 1];
        
        addLog(`‚è∞ ${lastClickedItem.name} foi o √∫ltimo a clicar no Poder do Dedo e deve beber!`);
        db.ref(`games/${gameCode}/players/${lastClickedItem.playerKey}/needsToDrink`).set(Date.now());
      }
      
      // Desativar o poder do dedo
      db.ref(`games/${gameCode}/fingerPower`).update({active: false, queue: []});
    });
  });
}

// Adicionar um bot√£o para o organizador finalizar o poder do dedo manualmente
// No renderHostGame, adicionar:
// Adicionar bot√£o para finalizar Poder do Dedo se estiver ativo
const fp = data.fingerPower || {};
if(fp.active) {
  // Pode adicionar um bot√£o espec√≠fico no painel do host para finalizar o poder do dedo
  if (!document.getElementById('btnFinalizeFinger')) {
    const btnFinalizeFinger = document.createElement('button');
    btnFinalizeFinger.id = 'btnFinalizeFinger';
    btnFinalizeFinger.className = 'btn-danger';
    btnFinalizeFinger.innerHTML = '<i class="fas fa-stop-circle"></i> Finalizar Poder do Dedo';
    btnFinalizeFinger.onclick = finalizeFingerPower;
    
    // Adicionar em um local vis√≠vel no layout
    document.querySelector('.left-panel').appendChild(btnFinalizeFinger);
  }
} else {
  // Remover o bot√£o se n√£o estiver ativo
  const btnFinalizeFinger = document.getElementById('btnFinalizeFinger');
  if (btnFinalizeFinger) {
    btnFinalizeFinger.remove();
  }
}
